# 【新人エンジニア向け】Excelシート削除ツール完全解説：一行ずつ丁寧にコードを読み解く

## はじめに

この記事では、Excelファイルからシートを削除するGUIツールのコードを一行ずつ詳しく解説します。新人エンジニアが実際のプロジェクトでよく遭遇する技術要素を含んでいるため、実践的な学習教材として活用してください。

## 全体構成の理解

```python
# ライブラリのインポート部分
import tkinter as tk                    # GUI作成用の標準ライブラリ
from tkinter import ttk, messagebox, filedialog  # tkinterの拡張モジュール
import os                              # ファイル・ディレクトリ操作用
import shutil                          # ファイルコピー・移動用
import zipfile                         # ZIP形式ファイル操作用
from datetime import datetime          # 日時処理用
from xml.etree import ElementTree as ET  # XML解析用（今回は使用していないが将来拡張用）
import tempfile                        # 一時ファイル作成用
import re                             # 正規表現用（今回は使用していないが将来拡張用）
```

**学習ポイント：ライブラリの選択理由**
- `tkinter`: Python標準のGUIライブラリ、追加インストール不要
- `zipfile`: ExcelファイルはZIP形式なので、内部構造にアクセス可能
- `tempfile`: 安全な一時ファイル操作でデータ破損リスクを軽減

## クラス設計とコンストラクタ

```python
class ExcelSheetDeleterGUI:
    """Excelシート削除ツールのメインクラス
    
    設計思想：
    - 単一責任の原則：Excelシート削除に特化
    - GUI とロジックの分離
    - エラーハンドリングの重視
    """
    
    def __init__(self, root):
        """コンストラクタ：アプリケーションの初期化
        
        Args:
            root: tkinterのルートウィンドウオブジェクト
        """
        self.root = root                    # ルートウィンドウの参照を保存
        self.root.title("Excel シート削除ツール（画像保持版）")  # ウィンドウタイトル設定
        self.root.geometry("600x550")       # ウィンドウサイズ設定（幅x高さ）
        self.root.resizable(True, True)     # ウィンドウサイズ変更を許可（横、縦）
        
        # 初期ファイルパス（開発・テスト用のデフォルト値）
        self.file_path = r"C:\Users\yukik\Desktop\excel\test\sales_demo_data.xlsx"
        
        # インスタンス変数の初期化
        self.sheet_info = {}               # シート情報を格納する辞書
        self.worksheets_data = {}          # ワークシートデータ（将来拡張用）
        
        # GUI作成とファイル読み込みを実行
        self.create_widgets()              # GUI要素を作成
        self.load_initial_file()           # 初期ファイルを読み込み
```

**学習ポイント：設計パターン**
- クラスベース設計：関連する機能をまとめて管理
- 初期化の分離：コンストラクタでは設定のみ、実際の処理は別メソッド
- 状態管理：インスタンス変数でアプリケーション状態を保持

## GUI作成メソッドの詳細解説

```python
def create_widgets(self):
    """GUI要素を作成するメソッド
    
    レイアウト設計：
    - 階層構造：メインフレーム > 機能別フレーム > 個別ウィジェット
    - グリッドレイアウト：整然とした配置
    - レスポンシブデザイン：ウィンドウサイズ変更に対応
    """
    
    # ===========================================
    # メインフレームの作成
    # ===========================================
    main_frame = ttk.Frame(self.root, padding="10")  # パディング10pxでマージン確保
    main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))  # グリッド配置、全方向に拡張
    
    # ===========================================
    # ファイル選択セクション
    # ===========================================
    file_frame = ttk.LabelFrame(main_frame, text="ファイル選択", padding="5")
    file_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
    
    # ファイルパス表示用のエントリーウィジェット
    self.file_path_var = tk.StringVar(value=self.file_path)  # StringVar：tkinterでテキスト管理
    file_entry = ttk.Entry(file_frame, textvariable=self.file_path_var, width=60)
    file_entry.grid(row=0, column=0, sticky=(tk.W, tk.E), padx=(0, 5))
    
    # ファイル選択ダイアログを開くボタン
    browse_btn = ttk.Button(file_frame, text="参照", command=self.browse_file)
    browse_btn.grid(row=0, column=1)
    
    # ファイル読み込み実行ボタン
    load_btn = ttk.Button(file_frame, text="読み込み", command=self.load_file)
    load_btn.grid(row=0, column=2, padx=(5, 0))
    
    # グリッドの重み設定：列0（エントリー）が拡張される
    file_frame.columnconfigure(0, weight=1)
```

**学習ポイント：GUI設計の基本**
- `ttk`使用理由：モダンな見た目、OS標準スタイルに準拠
- `sticky`パラメータ：方向指定でウィジェットの配置制御
- `columnconfigure(0, weight=1)`：レスポンシブレイアウトの実現

```python
    # ===========================================
    # ファイル情報表示セクション
    # ===========================================
    info_frame = ttk.LabelFrame(main_frame, text="ファイル情報", padding="5")
    info_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
    
    # ファイル情報を表示するラベル（動的に更新される）
    self.info_label = ttk.Label(info_frame, text="ファイルを読み込んでください")
    self.info_label.grid(row=0, column=0, sticky=tk.W)
    
    # ===========================================
    # 処理方法選択セクション
    # ===========================================
    method_frame = ttk.LabelFrame(main_frame, text="処理方法", padding="5")
    method_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
    
    # ラジオボタン用の変数（どの処理方法が選択されているかを管理）
    self.method_var = tk.StringVar(value="openpyxl_method")  # デフォルトは安定性重視
    
    # 標準方式のラジオボタン
    openpyxl_radio = ttk.Radiobutton(
        method_frame, 
        text="標準方式（openpyxl）- 高速・安定",   # ユーザーに分かりやすい説明
        variable=self.method_var,                  # 共通の変数で排他制御
        value="openpyxl_method"                    # この選択肢の識別子
    )
    openpyxl_radio.grid(row=0, column=0, sticky=tk.W)
    
    # 画像保持方式のラジオボタン
    hybrid_radio = ttk.Radiobutton(
        method_frame, 
        text="画像保持方式（ハイブリッド）- 画像・チャート保持", 
        variable=self.method_var, 
        value="hybrid_method"
    )
    hybrid_radio.grid(row=1, column=0, sticky=tk.W)
    
    # 注意書きラベル（ユーザーガイダンス）
    note_label = ttk.Label(
        method_frame, 
        text="※ 画像保持方式は処理時間が長くなりますが、より安全です", 
        font=("TkDefaultFont", 8),    # フォントサイズを小さく
        foreground="blue"             # 注意喚起のため青色
    )
    note_label.grid(row=2, column=0, sticky=tk.W, padx=(20, 0))  # インデントで階層表現
```

**学習ポイント：ユーザビリティ設計**
- ラジオボタンの排他制御：`StringVar`で状態管理
- 分かりやすいラベル：技術用語と効果を併記
- 視覚的な階層：色とインデントで情報の重要度を表現

```python
    # ===========================================
    # シート選択セクション（スクロール対応）
    # ===========================================
    sheet_frame = ttk.LabelFrame(main_frame, text="削除するシートを選択", padding="5")
    sheet_frame.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))
    
    # スクロール可能なキャンバスとスクロールバーの作成
    canvas = tk.Canvas(sheet_frame, height=200)  # 固定高さで表示領域を制限
    scrollbar = ttk.Scrollbar(sheet_frame, orient="vertical", command=canvas.yview)
    self.scrollable_frame = ttk.Frame(canvas)    # 実際のコンテンツを配置するフレーム
    
    # スクロール機能の実装
    self.scrollable_frame.bind(
        "<Configure>",  # フレームサイズ変更イベント
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))  # スクロール範囲を動的調整
    )
    
    # キャンバスにフレームを配置
    canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)  # スクロールバーとキャンバスを連携
    
    # グリッド配置
    canvas.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
    scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
    
    # レスポンシブレイアウト設定
    sheet_frame.columnconfigure(0, weight=1)  # キャンバスが水平方向に拡張
    sheet_frame.rowconfigure(0, weight=1)     # キャンバスが垂直方向に拡張
```

**学習ポイント：高度なGUI技術**
- キャンバス+スクロールバー：大量データの表示に対応
- イベントバインディング：動的なレイアウト調整
- lambda関数：簡潔なイベントハンドラ実装

```python
    # ===========================================
    # 操作ボタンセクション
    # ===========================================
    button_frame = ttk.Frame(main_frame)
    button_frame.grid(row=4, column=0, columnspan=2, pady=(0, 10))
    
    # 全選択ボタン
    select_all_btn = ttk.Button(button_frame, text="全選択", command=self.select_all)
    select_all_btn.grid(row=0, column=0, padx=(0, 5))
    
    # 全解除ボタン
    deselect_all_btn = ttk.Button(button_frame, text="全解除", command=self.deselect_all)
    deselect_all_btn.grid(row=0, column=1, padx=(0, 20))
    
    # バックアップ作成チェックボックス
    self.backup_var = tk.BooleanVar(value=True)  # デフォルトでバックアップ有効
    backup_check = ttk.Checkbutton(
        button_frame, 
        text="バックアップを作成", 
        variable=self.backup_var
    )
    backup_check.grid(row=0, column=2, padx=(0, 20))
    
    # メイン実行ボタン（アクセントスタイル）
    delete_btn = ttk.Button(
        button_frame, 
        text="選択したシートを削除", 
        command=self.delete_sheets, 
        style="Accent.TButton"  # 目立つスタイル
    )
    delete_btn.grid(row=0, column=3)
    
    # ===========================================
    # ステータスバー
    # ===========================================
    self.status_var = tk.StringVar(value="準備完了")  # 初期状態メッセージ
    status_bar = ttk.Label(
        main_frame, 
        textvariable=self.status_var, 
        relief=tk.SUNKEN,     # 凹んだ表示でステータスバーらしく
        anchor=tk.W           # 左寄せ
    )
    status_bar.grid(row=5, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(10, 0))
    
    # ===========================================
    # 全体のレスポンシブレイアウト設定
    # ===========================================
    main_frame.columnconfigure(0, weight=1)   # メインエリアが水平拡張
    main_frame.rowconfigure(3, weight=1)      # シート選択エリアが垂直拡張
    self.root.columnconfigure(0, weight=1)    # ルートウィンドウの拡張
    self.root.rowconfigure(0, weight=1)       # ルートウィンドウの拡張
```

**学習ポイント：プロフェッショナルなUI設計**
- デフォルト値の設定：安全性を重視（バックアップ有効）
- アクセシビリティ：色・形・位置で機能を区別
- ステータスフィードバック：ユーザーに現在の状態を明示

## ファイル操作メソッドの解説

```python
def browse_file(self):
    """ファイル選択ダイアログを開く
    
    ユーザビリティ重視の設計：
    - 適切なファイルフィルター
    - 前回のディレクトリを記憶
    - キャンセル時の適切な処理
    """
    file_path = filedialog.askopenfilename(
        title="Excelファイルを選択",                    # ダイアログのタイトル
        filetypes=[("Excel files", "*.xlsx *.xls"), ("All files", "*.*")],  # ファイルフィルター
        initialdir=os.path.dirname(self.file_path)     # 初期ディレクトリ（現在のファイルのディレクトリ）
    )
    
    # ファイルが選択された場合のみ処理（キャンセル時はNone）
    if file_path:
        self.file_path_var.set(file_path)  # GUI上の表示を更新
        self.file_path = file_path         # 内部状態を更新

def load_initial_file(self):
    """アプリケーション起動時の初期ファイル読み込み
    
    起動時体験の向上：
    - ファイルが存在する場合は自動読み込み
    - 存在しない場合は適切なメッセージ表示
    """
    if os.path.exists(self.file_path):           # ファイル存在チェック
        self.load_file()                         # 存在する場合は読み込み実行
    else:
        # 存在しない場合はステータスメッセージで通知
        self.status_var.set(f"初期ファイルが見つかりません: {self.file_path}")
```

**学習ポイント：エラー予防とUX**
- ファイルフィルター：ユーザーの操作ミスを防止
- 条件分岐：None チェックでキャンセル操作に対応
- 適切なフィードバック：エラー時も分かりやすいメッセージ

```python
def load_file(self):
    """Excelファイルを読み込み、シート情報を取得
    
    エラーハンドリング重視の設計：
    - 例外処理で予期せぬエラーに対応
    - ユーザーフィードバックで処理状況を明示
    - データの整合性確保
    """
    try:
        # GUI から現在のファイルパスを取得
        file_path = self.file_path_var.get()
        
        # ファイル存在チェック
        if not os.path.exists(file_path):
            messagebox.showerror("エラー", "ファイルが見つかりません")
            return  # エラー時は処理を中断
        
        # openpyxl を使用してファイル解析
        self.load_with_openpyxl(file_path)  # 実際の読み込み処理
        self.file_path = file_path          # 成功時にパスを更新
        
        # ファイル情報の表示更新
        sheet_count = len(self.sheet_info)          # シート数取得
        file_size = os.path.getsize(file_path)      # ファイルサイズ取得
        self.info_label.config(
            text=f"シート数: {sheet_count}, ファイルサイズ: {file_size:,} bytes"
        )  # カンマ区切りで読みやすく表示
        
        # GUI のシート選択部分を更新
        self.create_sheet_checkboxes()
        
        # 成功メッセージをステータスバーに表示
        self.status_var.set(f"ファイルを読み込みました: {os.path.basename(file_path)}")
        
    except Exception as e:
        # 予期せぬエラーの処理
        messagebox.showerror("エラー", f"ファイルの読み込みに失敗しました:\n{e}")
        self.status_var.set("エラー: ファイル読み込み失敗")

def load_with_openpyxl(self, file_path):
    """openpyxl ライブラリを使用してExcelファイルを解析
    
    Args:
        file_path (str): 読み込むExcelファイルのパス
    
    処理内容：
    - Excelファイルを安全に読み込み
    - シート情報を構造化して保存
    - アクティブシートの識別
    """
    from openpyxl import load_workbook  # 必要な時のみインポート（遅延インポート）
    
    self.sheet_info = {}  # シート情報をリセット
    workbook = load_workbook(file_path)  # Excelファイルを読み込み
    
    # 各シートの情報を収集
    for i, sheet_name in enumerate(workbook.sheetnames):
        self.sheet_info[sheet_name] = {
            'index': i,  # シートのインデックス番号
            # アクティブシート判定（安全にアクセス）
            'active': workbook.active.title == sheet_name if workbook.active else False
        }
```

**学習ポイント：堅牢なファイル処理**
- 多段階チェック：存在確認 → 読み込み → 解析
- 遅延インポート：必要な時のみライブラリを読み込み
- 構造化データ：辞書で情報を整理して管理

## シート選択UI の動的生成

```python
def create_sheet_checkboxes(self):
    """シート選択用チェックボックスを動的に生成
    
    動的UI設計：
    - ファイル内容に応じてUIを構築
    - アクティブシートの視覚的区別
    - スクロール対応の柔軟なレイアウト
    """
    
    # 既存のウィジェットをクリア（前回のファイルの残骸を削除）
    for widget in self.scrollable_frame.winfo_children():
        widget.destroy()  # メモリリーク防止
    
    self.sheet_vars = {}  # チェックボックスの状態管理用辞書
    
    # 各シート用のチェックボックスを動的生成
    for i, (sheet_name, info) in enumerate(self.sheet_info.items()):
        # 各シート用のBoolean変数（チェック状態管理）
        var = tk.BooleanVar()
        self.sheet_vars[sheet_name] = var  # シート名をキーとして保存
        
        # シート1行分のコンテナフレーム
        frame = ttk.Frame(self.scrollable_frame)
        frame.grid(row=i, column=0, sticky=(tk.W, tk.E), padx=5, pady=2)
        
        # チェックボックス本体
        checkbox = ttk.Checkbutton(frame, variable=var)
        checkbox.grid(row=0, column=0)
        
        # シート名表示ラベル
        label = ttk.Label(frame, text=f"{sheet_name}")
        label.grid(row=0, column=1, sticky=tk.W, padx=(5, 0))
        
        # アクティブなシートの特別表示
        if info.get('active', False):  # safety get() でKeyError回避
            # フォントと色を変更してアクティブシートを強調
            label.config(foreground="blue", font=("TkDefaultFont", 9, "bold"))
            
            # "アクティブ"ラベルを追加
            active_label = ttk.Label(
                frame, 
                text="(アクティブ)", 
                foreground="blue", 
                font=("TkDefaultFont", 8)
            )
            active_label.grid(row=0, column=2, sticky=tk.W, padx=(5, 0))
        
        # フレーム内のレスポンシブレイアウト
        frame.columnconfigure(1, weight=1)  # シート名ラベルが拡張
    
    # スクロールフレーム全体のレスポンシブ設定
    self.scrollable_frame.columnconfigure(0, weight=1)

def select_all(self):
    """全シートを選択状態にする便利機能"""
    for var in self.sheet_vars.values():
        var.set(True)  # 全てのBooleanVarをTrueに設定

def deselect_all(self):
    """全シートの選択を解除する便利機能"""
    for var in self.sheet_vars.values():
        var.set(False)  # 全てのBooleanVarをFalseに設定
```

**学習ポイント：動的UI とデータバインディング**
- ウィジェットの動的生成：データ量に応じた柔軟なUI
- 状態管理：辞書でチェックボックス状態を管理
- ユーザビリティ：一括選択機能で操作性向上

## 画像保持機能の実装

```python
def extract_media_files(self, zip_file):
    """Excelファイル（ZIP形式）から画像・メディアファイルを抽出
    
    Args:
        zip_file: ZipFileオブジェクト
    
    Returns:
        dict: ファイル名をキー、バイナリデータを値とする辞書
    
    技術的なポイント：
    - ExcelファイルはZIP形式として扱える
    - 画像は特定のディレクトリに格納されている
    - バイナリデータとして保存
    """
    media_files = {}  # 抽出したファイルを格納する辞書
    
    try:
        # ZIPファイル内の全ファイルをチェック
        for file_info in zip_file.infolist():
            filename = file_info.filename
            
            # 画像・メディア関連ファイルの判定
            if (filename.startswith('xl/media/') or        # 画像ファイル
                filename.startswith('xl/charts/') or       # チャートファイル
                filename.startswith('xl/drawings/') or     # 描画ファイル
                filename.startswith('xl/embeddings/') or   # 埋め込みオブジェクト
                filename.startswith('xl/printerSettings/') or  # 印刷設定
                filename.startswith('xl/theme/') or        # テーマファイル
                filename.startswith('xl/vbaProject') or    # VBAプロジェクト
                # 拡張子による判定（フォルダ外に存在する可能性）
                filename.endswith('.png') or
                filename.endswith('.jpg') or 
                filename.endswith('.jpeg') or 
                filename.endswith('.gif') or
                filename.endswith('.bmp') or
                filename.endswith('.emf') or     # Enhanced Metafile
                filename.endswith('.wmf')):      # Windows Metafile
                
                try:
                    # バイナリデータとして読み込み
                    media_files[filename] = zip_file.read(filename)
                except Exception as e:
                    # 個別ファイルの読み込み失敗は全体に影響させない
                    print(f"メディアファイル読み込みエラー {filename}: {e}")
                    continue  # エラーファイルはスキップして処理継続
                        
    except Exception as e:
        # 全体的なエラーもログ出力のみで処理継続
        print(f"メディアファイル抽出エラー: {e}")
        
    return media_files  # 成功分のみ返却
```

**学習ポイント：ファイル形式の深い理解**
- Excel内部構造：ZIPとしての構造理解
- エラー分離：個別失敗が全体に影響しない設計
- 複数条件判定：OR演算子の効果的な使用

## メイン処理：ハイブリッド削除方式

```python
def delete_sheets_hybrid_method(self, selected_sheets):
    """ハイブリッド方式でシート削除（画像保持機能付き）
    
    Args:
        selected_sheets (list): 削除対象シート名のリスト
    
    Returns:
        bool: 処理成功時True、失敗時False
    
    処理フロー：
    1. 画像・メディアファイル抽出
    2. openpyxlでシート削除
    3. ファイル保存
    4. 画像ファイル復元
    """
    try:
        # Step 1: 処理開始の通知
        self.status_var.set("画像保持方式で処理中...")
        self.root.update()  # GUIを即座に更新（フリーズ防止）
        
        # Step 2: 元ファイルから画像・メディアファイルを抽出
        self.status_var.set("画像・メディアファイルを抽出中...")
        self.root.update()
        
        media_files = {}  # 抽出したファイルを格納
        try:
            # ZipFileとして開いて解析
            with zipfile.ZipFile(self.file_path, 'r') as original_zip:
                media_files = self.extract_media_files(original_zip)
                
            # 抽出結果をユーザーに通知
            self.status_var.set(f"抽出完了: {len(media_files)}個のメディアファイル")
            self.root.update()
            
        except Exception as e:
            print(f"メディアファイル抽出でエラー: {e}")
            # 抽出に失敗しても処理を続行（基本機能は動作）
        
        # Step 3: openpyxlでシート削除
        self.status_var.set("シートを削除中...")
        self.root.update()
        
        from openpyxl import load_workbook  # 必要な時点でインポート
        workbook = load_workbook(self.file_path)
        
        deleted_count = 0  # 削除成功したシート数のカウンター
        for sheet_name in selected_sheets:
            if sheet_name in workbook.sheetnames:  # 存在確認（安全性）
                try:
                    sheet = workbook[sheet_name]    # シートオブジェクト取得
                    workbook.remove(sheet)          # シート削除
                    deleted_count += 1              # カウンター更新
                    # 進捗表示（ユーザーフィードバック）
                    self.status_var.set(f"削除中: {sheet_name} ({deleted_count}/{len(selected_sheets)})")
                    self.root.update()
                except Exception as e:
                    # 個別シートの削除失敗は記録して継続
                    print(f"シート削除エラー {sheet_name}: {e}")
                    continue
        
        # Step 4: ファイルを保存
        self.status_var.set("ファイルを保存中...")
        self.root.update()
        workbook.save(self.file_path)  # 削除結果を保存
        
        # Step 5: 画像・メディアファイルを復元（可能な場合のみ）
        if media_files:  # 抽出済みファイルがある場合
            self.status_var.set("画像・メディアファイルを復元中...")
            self.root.update()
            
            try:
                # 一時ファイルを作成してメディアファイルを追加
                temp_path = self.file_path + '.temp'  # 安全な一時ファイル名
                
                # 既存ファイルをベースに新しいZIPファイルを作成
                with zipfile.ZipFile(self.file_path, 'r') as source_zip:
                    with zipfile.ZipFile(temp_path, 'w', zipfile.ZIP_DEFLATED) as target_zip:
                        
                        # 既存の全ファイルをコピー
                        for item in source_zip.infolist():
                            try:
                                data = source_zip.read(item.filename)
                                target_zip.writestr(item, data)  # メタデータも保持
                            except Exception as e:
                                print(f"ファイルコピーエラー {item.filename}: {e}")
                                continue  # エラーファイルはスキップ
                        
                        # メディアファイルを追加（競合回避）
                        added_count = 0
                        for filename, data in media_files.items():
                            try:
                                # 重複チェック（データ破損防止）
                                existing_files = [f.filename for f in target_zip.infolist()]
                                if filename not in existing_files:
                                    target_zip.writestr(filename, data)
                                    added_count += 1
                            except Exception as e:
                                print(f"メディアファイル追加エラー {filename}: {e}")
                                continue
                
                # 元ファイルを安全に置き換え
                if os.path.exists(temp_path):
                    shutil.move(temp_path, self.file_path)  # 原子的操作
                    self.status_var.set(f"画像復元完了: {added_count}個のファイルを復元")
                
            except Exception as e:
                print(f"画像復元エラー: {e}")
                # 復元に失敗しても、基本的なシート削除は成功しているので続行
                if 'temp_path' in locals() and os.path.exists(temp_path):
                    os.remove(temp_path)  # 一時ファイルクリーンアップ
                self.status_var.set("シート削除完了（画像復元は部分的）")
        
        self.status_var.set(f"処理完了: {deleted_count}個のシート削除")
        return True  # 成功
        
    except Exception as e:
        self.status_var.set(f"ハイブリッド処理エラー: {str(e)}")
        # 重要：エラー時のフォールバック機能
        print(f"ハイブリッド方式エラー、標準方式にフォールバック: {e}")
        return self.delete_sheets_openpyxl_method(selected_sheets)

def delete_sheets_openpyxl_method(self, selected_sheets):
    """標準方式（openpyxl）でシート削除
    
    Args:
        selected_sheets (list): 削除対象シート名のリスト
    
    Returns:
        bool: 処理成功時True
    
    特徴：
    - 高速で安定
    - 画像は保持されない
    - エラー耐性が高い
    """
    try:
        from openpyxl import load_workbook
        
        # Step 1: ファイル読み込み
        self.status_var.set("Excelファイルを読み込み中...")
        self.root.update()
        
        workbook = load_workbook(self.file_path)
        
        # Step 2: 削除前の状態確認
        initial_sheet_count = len(workbook.sheetnames)
        self.status_var.set(f"削除処理中... (現在のシート数: {initial_sheet_count})")
        self.root.update()
        
        # Step 3: シート削除ループ
        deleted_count = 0
        for sheet_name in selected_sheets:
            if sheet_name in workbook.sheetnames:  # 存在確認
                try:
                    sheet = workbook[sheet_name]
                    workbook.remove(sheet)
                    deleted_count += 1
                    # リアルタイム進捗表示
                    self.status_var.set(f"削除中: {sheet_name} ({deleted_count}/{len(selected_sheets)})")
                    self.root.update()
                except Exception as e:
                    print(f"シート '{sheet_name}' の削除中にエラー: {e}")
                    continue  # 個別エラーは継続
        
        # Step 4: 安全性チェック
        final_sheet_count = len(workbook.sheetnames)
        if final_sheet_count == 0:
            raise ValueError("すべてのシートが削除されました。最低1つのシートは必要です。")
        
        # Step 5: ファイル保存
        self.status_var.set("ファイルを保存中...")
        self.root.update()
        
        workbook.save(self.file_path)
        
        self.status_var.set(f"保存完了: {deleted_count}個のシートを削除")
        return True
        
    except Exception as e:
        self.status_var.set(f"openpyxl処理エラー: {str(e)}")
        raise e  # 上位に例外を伝播

def delete_sheets(self):
    """メインの削除処理メソッド
    
    処理フロー：
    1. 入力値検証
    2. ユーザー確認
    3. バックアップ作成
    4. 削除実行
    5. 結果確認・フィードバック
    
    エラーハンドリング：
    - 段階的なエラーチェック
    - ユーザーフレンドリーなエラーメッセージ
    - 自動復旧機能
    """
    
    # Step 1: 事前チェック
    if not self.sheet_info:
        messagebox.showerror("エラー", "ファイルが読み込まれていません")
        return
    
    # Step 2: 選択されたシートを取得
    selected_sheets = [
        sheet_name for sheet_name, var in self.sheet_vars.items() 
        if var.get()  # チェックされているもののみ
    ]
    
    # Step 3: 選択数チェック
    if not selected_sheets:
        messagebox.showwarning("警告", "削除するシートが選択されていません")
        return
    
    # Step 4: 残存シート数チェック（重要な安全機能）
    remaining_sheets = len(self.sheet_info) - len(selected_sheets)
    if remaining_sheets < 1:
        messagebox.showerror(
            "エラー", 
            "最低1つのシートは必要です。\nすべてのシートを削除することはできません。"
        )
        return
    
    # Step 5: ユーザー確認ダイアログ
    method_text = (
        "画像保持方式（ハイブリッド）" if self.method_var.get() == "hybrid_method" 
        else "標準方式（openpyxl）"
    )
    message = f"処理方法: {method_text}\n\n以下のシートを削除しますか？\n\n"
    message += "\n".join(f"• {sheet}" for sheet in selected_sheets)
    message += f"\n\n残るシート数: {remaining_sheets}個"
    
    if not messagebox.askyesno("確認", message):
        return  # ユーザーがキャンセル
    
    # Step 6: バックアップ処理
    backup_path = None
    
    try:
        # バックアップ作成（推奨設定）
        if self.backup_var.get():
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            # 拡張子別の処理
            backup_path = self.file_path.replace('.xlsx', f'_backup_{timestamp}.xlsx')
            backup_path = backup_path.replace('.xls', f'_backup_{timestamp}.xls')
            shutil.copy2(self.file_path, backup_path)  # メタデータも保持
            self.status_var.set(f"バックアップ作成: {os.path.basename(backup_path)}")
        
        # Step 7: ファイルアクセス可能性チェック
        self.check_file_accessibility()
        
        # Step 8: 削除処理実行（方式選択）
        success = False
        if self.method_var.get() == "hybrid_method":
            success = self.delete_sheets_hybrid_method(selected_sheets)
        else:
            success = self.delete_sheets_openpyxl_method(selected_sheets)
        
        # Step 9: 成功時の処理
        if success:
            self.load_file()  # ファイルを再読み込みしてGUI更新
            messagebox.showinfo("完了", f"{len(selected_sheets)}個のシートを削除しました")
            self.status_var.set(f"削除完了: {len(selected_sheets)}個のシート")
        else:
            self.status_var.set("削除処理が完了しませんでした")
        
    # Step 10: エラーハンドリング（詳細分類）
    except PermissionError as e:
        error_msg = (
            f"ファイルアクセス権限エラー:\n{e}\n\n"
            "以下を確認してください:\n"
            "• Excelファイルが他のアプリで開かれていないか\n"
            "• ファイルが読み取り専用になっていないか\n"
            "• 管理者権限で実行する必要があるか"
        )
        messagebox.showerror("権限エラー", error_msg)
        self.status_var.set("エラー: ファイルアクセス権限")
        
    except FileNotFoundError as e:
        error_msg = f"ファイルが見つかりません:\n{e}\n\nファイルパスを確認してください。"
        messagebox.showerror("ファイルエラー", error_msg)
        self.status_var.set("エラー: ファイル未発見")
        
    except Exception as e:
        error_msg = (
            f"削除処理中にエラーが発生しました:\n\n"
            f"エラータイプ: {type(e).__name__}\n"
            f"エラー詳細: {str(e)}\n\n"
            "バックアップファイルから復元してください。"
        )
        messagebox.showerror("処理エラー", error_msg)
        self.status_var.set("エラー: 削除処理失敗")
        
        # Step 11: 自動復旧機能（ユーザーフレンドリー）
        if backup_path and os.path.exists(backup_path):
            restore_msg = (
                f"エラーが発生しました。バックアップファイルから復元しますか?\n\n"
                f"バックアップ: {os.path.basename(backup_path)}"
            )
            if messagebox.askyesno("復元", restore_msg):
                try:
                    shutil.copy2(backup_path, self.file_path)
                    self.load_file()  # GUI更新
                    messagebox.showinfo("復元完了", "バックアップファイルから復元しました")
                    self.status_var.set("バックアップから復元完了")
                except Exception as restore_error:
                    messagebox.showerror("復元エラー", f"復元に失敗しました:\n{restore_error}")

def check_file_accessibility(self):
    """ファイルアクセス可能性チェック
    
    事前チェックにより処理中のエラーを予防：
    - ファイルロック状態の確認
    - 権限問題の早期発見
    """
    try:
        # 書き込みモードで開いてみる（実際は何も書き込まない）
        with open(self.file_path, 'r+b') as f:
            pass  # ファイルアクセステストのみ
    except PermissionError:
        raise PermissionError(f"ファイルがロックされています: {self.file_path}")
    except FileNotFoundError:
        raise FileNotFoundError(f"ファイルが見つかりません: {self.file_path}")


def main():
    """アプリケーションのエントリーポイント
    
    標準的なGUIアプリケーションの起動パターン：
    - ルートウィンドウ作成
    - アプリケーションインスタンス生成
    - メインループ開始
    """
    root = tk.Tk()                    # メインウィンドウ作成
    app = ExcelSheetDeleterGUI(root)  # アプリケーション初期化
    root.mainloop()                   # イベントループ開始（ブロッキング）


# Pythonの標準的な実行制御
if __name__ == "__main__":
    """
    このスクリプトが直接実行された場合のみmain()を呼び出し
    他のモジュールからimportされた場合は実行されない
    """
    main()

## まとめ：新人エンジニアが学べる設計原則

### 1. **エラーハンドリングの階層化**
```python
try:
    # メイン処理
except SpecificError as e:
    # 具体的なエラーへの対応
except Exception as e:
    # 予期せぬエラーへの対応
```

### 2. **ユーザーフィードバックの重要性**
```python
self.status_var.set("処理中...")
self.root.update()  # GUI即座更新
```

### 3. **段階的処理設計**
```python
# Step 1: 検証
# Step 2: 準備
# Step 3: 実行
# Step 4: 確認
```

### 4. **フォールバック機能**
```python
try:
    advanced_method()
except:
    fallback_to_basic_method()
```

### 5. **データ保護の徹底**
```python
# バックアップ → 処理 → 検証 → 復旧オプション
```

このコードは、実際のプロダクション環境で求められる品質基準を満たすよう設計されており、新人エンジニアにとって実践的な学習教材となっています。

ーーーーーーーーーーーーーーーーーーーーーーーーーーーー
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import os
import shutil
import zipfile
from datetime import datetime
from xml.etree import ElementTree as ET
import tempfile
import re


class ExcelSheetDeleterGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Excel シート削除ツール（画像保持版）")
        self.root.geometry("600x550")
        self.root.resizable(True, True)
        
        # 初期ファイルパス
        self.file_path = r"C:\Users\yukik\Desktop\excel\test\sales_demo_data.xlsx"
        self.sheet_info = {}
        self.worksheets_data = {}
        
        self.create_widgets()
        self.load_initial_file()
    
    def create_widgets(self):
        # メインフレーム
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # ファイル選択フレーム
        file_frame = ttk.LabelFrame(main_frame, text="ファイル選択", padding="5")
        file_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        # ファイルパス表示
        self.file_path_var = tk.StringVar(value=self.file_path)
        file_entry = ttk.Entry(file_frame, textvariable=self.file_path_var, width=60)
        file_entry.grid(row=0, column=0, sticky=(tk.W, tk.E), padx=(0, 5))
        
        # ファイル選択ボタン
        browse_btn = ttk.Button(file_frame, text="参照", command=self.browse_file)
        browse_btn.grid(row=0, column=1)
        
        # 読み込みボタン
        load_btn = ttk.Button(file_frame, text="読み込み", command=self.load_file)
        load_btn.grid(row=0, column=2, padx=(5, 0))
        
        file_frame.columnconfigure(0, weight=1)
        
        # ファイル情報フレーム
        info_frame = ttk.LabelFrame(main_frame, text="ファイル情報", padding="5")
        info_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        self.info_label = ttk.Label(info_frame, text="ファイルを読み込んでください")
        self.info_label.grid(row=0, column=0, sticky=tk.W)
        
        # 処理方法選択フレーム
        method_frame = ttk.LabelFrame(main_frame, text="処理方法", padding="5")
        method_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        self.method_var = tk.StringVar(value="openpyxl_method")
        
        openpyxl_radio = ttk.Radiobutton(method_frame, text="標準方式（openpyxl）- 高速・安定", 
                                        variable=self.method_var, value="openpyxl_method")
        openpyxl_radio.grid(row=0, column=0, sticky=tk.W)
        
        hybrid_radio = ttk.Radiobutton(method_frame, text="画像保持方式（ハイブリッド）- 画像・チャート保持", 
                                      variable=self.method_var, value="hybrid_method")
        hybrid_radio.grid(row=1, column=0, sticky=tk.W)
        
        # 注意書きラベル
        note_label = ttk.Label(method_frame, text="※ 画像保持方式は処理時間が長くなりますが、より安全です", 
                              font=("TkDefaultFont", 8), foreground="blue")
        note_label.grid(row=2, column=0, sticky=tk.W, padx=(20, 0))
        
        # シート選択フレーム
        sheet_frame = ttk.LabelFrame(main_frame, text="削除するシートを選択", padding="5")
        sheet_frame.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))
        
        # スクロール可能なフレーム
        canvas = tk.Canvas(sheet_frame, height=200)
        scrollbar = ttk.Scrollbar(sheet_frame, orient="vertical", command=canvas.yview)
        self.scrollable_frame = ttk.Frame(canvas)
        
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        
        sheet_frame.columnconfigure(0, weight=1)
        sheet_frame.rowconfigure(0, weight=1)
        
        # 操作ボタンフレーム
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=4, column=0, columnspan=2, pady=(0, 10))
        
        # 全選択/全解除ボタン
        select_all_btn = ttk.Button(button_frame, text="全選択", command=self.select_all)
        select_all_btn.grid(row=0, column=0, padx=(0, 5))
        
        deselect_all_btn = ttk.Button(button_frame, text="全解除", command=self.deselect_all)
        deselect_all_btn.grid(row=0, column=1, padx=(0, 20))
        
        # バックアップ設定
        self.backup_var = tk.BooleanVar(value=True)
        backup_check = ttk.Checkbutton(button_frame, text="バックアップを作成", variable=self.backup_var)
        backup_check.grid(row=0, column=2, padx=(0, 20))
        
        # 削除ボタン
        delete_btn = ttk.Button(button_frame, text="選択したシートを削除", command=self.delete_sheets, style="Accent.TButton")
        delete_btn.grid(row=0, column=3)
        
        # ステータスバー
        self.status_var = tk.StringVar(value="準備完了")
        status_bar = ttk.Label(main_frame, textvariable=self.status_var, relief=tk.SUNKEN, anchor=tk.W)
        status_bar.grid(row=5, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(10, 0))
        
        # グリッドの重み設定
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(3, weight=1)
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
    
    def browse_file(self):
        """ファイル選択ダイアログを開く"""
        file_path = filedialog.askopenfilename(
            title="Excelファイルを選択",
            filetypes=[("Excel files", "*.xlsx *.xls"), ("All files", "*.*")],
            initialdir=os.path.dirname(self.file_path)
        )
        if file_path:
            self.file_path_var.set(file_path)
            self.file_path = file_path
    
    def load_initial_file(self):
        """初期ファイルを読み込む"""
        if os.path.exists(self.file_path):
            self.load_file()
        else:
            self.status_var.set(f"初期ファイルが見つかりません: {self.file_path}")
    
    def load_file(self):
        """Excelファイルを読み込む"""
        try:
            file_path = self.file_path_var.get()
            if not os.path.exists(file_path):
                messagebox.showerror("エラー", "ファイルが見つかりません")
                return
            
            # openpyxlで基本情報を取得
            self.load_with_openpyxl(file_path)
            self.file_path = file_path
            
            # ファイル情報を更新
            sheet_count = len(self.sheet_info)
            file_size = os.path.getsize(file_path)
            self.info_label.config(text=f"シート数: {sheet_count}, ファイルサイズ: {file_size:,} bytes")
            
            # シート選択チェックボックスを作成
            self.create_sheet_checkboxes()
            
            self.status_var.set(f"ファイルを読み込みました: {os.path.basename(file_path)}")
            
        except Exception as e:
            messagebox.showerror("エラー", f"ファイルの読み込みに失敗しました:\n{e}")
            self.status_var.set("エラー: ファイル読み込み失敗")
    
    def load_with_openpyxl(self, file_path):
        """openpyxlでExcelファイルを読み込む"""
        from openpyxl import load_workbook
        
        self.sheet_info = {}
        workbook = load_workbook(file_path)
        
        for i, sheet_name in enumerate(workbook.sheetnames):
            self.sheet_info[sheet_name] = {
                'index': i,
                'active': workbook.active.title == sheet_name if workbook.active else False
            }
    
    def create_sheet_checkboxes(self):
        """シート選択用のチェックボックスを作成"""
        # 既存のウィジェットを削除
        for widget in self.scrollable_frame.winfo_children():
            widget.destroy()
        
        self.sheet_vars = {}
        
        # 各シート用のチェックボックスを作成
        for i, (sheet_name, info) in enumerate(self.sheet_info.items()):
            var = tk.BooleanVar()
            self.sheet_vars[sheet_name] = var
            
            # チェックボックスとシート名を表示
            frame = ttk.Frame(self.scrollable_frame)
            frame.grid(row=i, column=0, sticky=(tk.W, tk.E), padx=5, pady=2)
            
            checkbox = ttk.Checkbutton(frame, variable=var)
            checkbox.grid(row=0, column=0)
            
            label = ttk.Label(frame, text=f"{sheet_name}")
            label.grid(row=0, column=1, sticky=tk.W, padx=(5, 0))
            
            # アクティブなシートは異なる色で表示
            if info.get('active', False):
                label.config(foreground="blue", font=("TkDefaultFont", 9, "bold"))
                active_label = ttk.Label(frame, text="(アクティブ)", foreground="blue", font=("TkDefaultFont", 8))
                active_label.grid(row=0, column=2, sticky=tk.W, padx=(5, 0))
            
            frame.columnconfigure(1, weight=1)
        
        self.scrollable_frame.columnconfigure(0, weight=1)
    
    def select_all(self):
        """すべてのシートを選択"""
        for var in self.sheet_vars.values():
            var.set(True)
    
    def deselect_all(self):
        """すべてのシートの選択を解除"""
        for var in self.sheet_vars.values():
            var.set(False)
    
    def extract_media_files(self, zip_file):
        """Excelファイルから画像やメディアファイルを抽出"""
        media_files = {}
        
        try:
            for file_info in zip_file.infolist():
                filename = file_info.filename
                
                # 画像、チャート、描画関連ファイルを特定
                if (filename.startswith('xl/media/') or 
                    filename.startswith('xl/charts/') or 
                    filename.startswith('xl/drawings/') or
                    filename.startswith('xl/embeddings/') or
                    filename.startswith('xl/printerSettings/') or
                    filename.startswith('xl/theme/') or
                    filename.startswith('xl/vbaProject') or
                    filename.endswith('.png') or
                    filename.endswith('.jpg') or 
                    filename.endswith('.jpeg') or 
                    filename.endswith('.gif') or
                    filename.endswith('.bmp') or
                    filename.endswith('.emf') or
                    filename.endswith('.wmf')):
                    
                    try:
                        media_files[filename] = zip_file.read(filename)
                    except Exception as e:
                        print(f"メディアファイル読み込みエラー {filename}: {e}")
                        continue
                        
        except Exception as e:
            print(f"メディアファイル抽出エラー: {e}")
            
        return media_files
    
    def delete_sheets_hybrid_method(self, selected_sheets):
        """ハイブリッド方式でシートを削除（画像・チャート保持、エラー回避）"""
        try:
            self.status_var.set("画像保持方式で処理中...")
            self.root.update()
            
            # Step 1: 元ファイルから画像・メディアファイルを抽出
            self.status_var.set("画像・メディアファイルを抽出中...")
            self.root.update()
            
            media_files = {}
            try:
                with zipfile.ZipFile(self.file_path, 'r') as original_zip:
                    media_files = self.extract_media_files(original_zip)
                    
                self.status_var.set(f"抽出完了: {len(media_files)}個のメディアファイル")
                self.root.update()
                
            except Exception as e:
                print(f"メディアファイル抽出でエラー: {e}")
                # 抽出に失敗しても処理を続行
            
            # Step 2: openpyxlでシートを削除
            self.status_var.set("シートを削除中...")
            self.root.update()
            
            from openpyxl import load_workbook
            workbook = load_workbook(self.file_path)
            
            deleted_count = 0
            for sheet_name in selected_sheets:
                if sheet_name in workbook.sheetnames:
                    try:
                        sheet = workbook[sheet_name]
                        workbook.remove(sheet)
                        deleted_count += 1
                        self.status_var.set(f"削除中: {sheet_name} ({deleted_count}/{len(selected_sheets)})")
                        self.root.update()
                    except Exception as e:
                        print(f"シート削除エラー {sheet_name}: {e}")
                        continue
            
            # Step 3: ファイルを保存
            self.status_var.set("ファイルを保存中...")
            self.root.update()
            workbook.save(self.file_path)
            
            # Step 4: 画像・メディアファイルを復元（可能な場合のみ）
            if media_files:
                self.status_var.set("画像・メディアファイルを復元中...")
                self.root.update()
                
                try:
                    # 一時ファイルを作成してメディアファイルを追加
                    temp_path = self.file_path + '.temp'
                    
                    with zipfile.ZipFile(self.file_path, 'r') as source_zip:
                        with zipfile.ZipFile(temp_path, 'w', zipfile.ZIP_DEFLATED) as target_zip:
                            
                            # 既存のファイルをコピー
                            for item in source_zip.infolist():
                                try:
                                    data = source_zip.read(item.filename)
                                    target_zip.writestr(item, data)
                                except Exception as e:
                                    print(f"ファイルコピーエラー {item.filename}: {e}")
                                    continue
                            
                            # メディアファイルを追加（競合しない場合のみ）
                            added_count = 0
                            for filename, data in media_files.items():
                                try:
                                    # ファイルが既に存在するかチェック
                                    existing_files = [f.filename for f in target_zip.infolist()]
                                    if filename not in existing_files:
                                        target_zip.writestr(filename, data)
                                        added_count += 1
                                except Exception as e:
                                    print(f"メディアファイル追加エラー {filename}: {e}")
                                    continue
                    
                    # 元ファイルを置き換え
                    if os.path.exists(temp_path):
                        shutil.move(temp_path, self.file_path)
                        self.status_var.set(f"画像復元完了: {added_count}個のファイルを復元")
                    
                except Exception as e:
                    print(f"画像復元エラー: {e}")
                    # 復元に失敗しても、基本的なシート削除は成功しているので続行
                    if os.path.exists(temp_path):
                        os.remove(temp_path)
                    self.status_var.set("シート削除完了（画像復元は部分的）")
            
            self.status_var.set(f"処理完了: {deleted_count}個のシート削除")
            return True
            
        except Exception as e:
            self.status_var.set(f"ハイブリッド処理エラー: {str(e)}")
            # エラーが発生してもopenpyxl方式にフォールバック
            print(f"ハイブリッド方式エラー、標準方式にフォールバック: {e}")
            return self.delete_sheets_openpyxl_method(selected_sheets)
    
    def delete_sheets_openpyxl_method(self, selected_sheets):
        """openpyxl方式でシートを削除（安定・推奨）"""
        try:
            from openpyxl import load_workbook
            
            # ファイルを読み込み
            self.status_var.set("Excelファイルを読み込み中...")
            self.root.update()
            
            workbook = load_workbook(self.file_path)
            
            # 削除前のシート数を確認
            initial_sheet_count = len(workbook.sheetnames)
            self.status_var.set(f"削除処理中... (現在のシート数: {initial_sheet_count})")
            self.root.update()
            
            # シートを削除
            deleted_count = 0
            for sheet_name in selected_sheets:
                if sheet_name in workbook.sheetnames:
                    try:
                        sheet = workbook[sheet_name]
                        workbook.remove(sheet)
                        deleted_count += 1
                        self.status_var.set(f"削除中: {sheet_name} ({deleted_count}/{len(selected_sheets)})")
                        self.root.update()
                    except Exception as e:
                        print(f"シート '{sheet_name}' の削除中にエラー: {e}")
                        continue
            
            # 削除後のシート数を確認
            final_sheet_count = len(workbook.sheetnames)
            
            if final_sheet_count == 0:
                raise ValueError("すべてのシートが削除されました。最低1つのシートは必要です。")
            
            # ファイルを保存
            self.status_var.set("ファイルを保存中...")
            self.root.update()
            
            workbook.save(self.file_path)
            
            self.status_var.set(f"保存完了: {deleted_count}個のシートを削除")
            return True
            
        except Exception as e:
            self.status_var.set(f"openpyxl処理エラー: {str(e)}")
            raise e
    
    def delete_sheets(self):
        """選択されたシートを削除"""
        if not self.sheet_info:
            messagebox.showerror("エラー", "ファイルが読み込まれていません")
            return
        
        # 選択されたシートを取得
        selected_sheets = [sheet_name for sheet_name, var in self.sheet_vars.items() if var.get()]
        
        if not selected_sheets:
            messagebox.showwarning("警告", "削除するシートが選択されていません")
            return
        
        # 残るシートが1つ以上あるかチェック
        remaining_sheets = len(self.sheet_info) - len(selected_sheets)
        if remaining_sheets < 1:
            messagebox.showerror("エラー", "最低1つのシートは必要です。\nすべてのシートを削除することはできません。")
            return
        
        # 確認ダイアログ
        method_text = "画像保持方式（ハイブリッド）" if self.method_var.get() == "hybrid_method" else "標準方式（openpyxl）"
        message = f"処理方法: {method_text}\n\n以下のシートを削除しますか？\n\n"
        message += "\n".join(f"• {sheet}" for sheet in selected_sheets)
        message += f"\n\n残るシート数: {remaining_sheets}個"
        
        if not messagebox.askyesno("確認", message):
            return
        
        # バックアップファイルパス
        backup_path = None
        
        try:
            # バックアップを作成
            if self.backup_var.get():
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_path = self.file_path.replace('.xlsx', f'_backup_{timestamp}.xlsx')
                backup_path = backup_path.replace('.xls', f'_backup_{timestamp}.xls')  # .xlsの場合も対応
                shutil.copy2(self.file_path, backup_path)
                self.status_var.set(f"バックアップ作成: {os.path.basename(backup_path)}")
            
            # ファイルがロックされていないか確認
            self.check_file_accessibility()
            
            # 選択した方式でシートを削除
            success = False
            if self.method_var.get() == "hybrid_method":
                success = self.delete_sheets_hybrid_method(selected_sheets)
            else:
                success = self.delete_sheets_openpyxl_method(selected_sheets)
            
            if success:
                # ファイル情報を更新
                self.load_file()  # ファイルを再読み込み
                
                messagebox.showinfo("完了", f"{len(selected_sheets)}個のシートを削除しました")
                self.status_var.set(f"削除完了: {len(selected_sheets)}個のシート")
            else:
                self.status_var.set("削除処理が完了しませんでした")
            
        except PermissionError as e:
            error_msg = f"ファイルアクセス権限エラー:\n{e}\n\n以下を確認してください:\n• Excelファイルが他のアプリで開かれていないか\n• ファイルが読み取り専用になっていないか\n• 管理者権限で実行する必要があるか"
            messagebox.showerror("権限エラー", error_msg)
            self.status_var.set("エラー: ファイルアクセス権限")
            
        except FileNotFoundError as e:
            error_msg = f"ファイルが見つかりません:\n{e}\n\nファイルパスを確認してください。"
            messagebox.showerror("ファイルエラー", error_msg)
            self.status_var.set("エラー: ファイル未発見")
            
        except Exception as e:
            error_msg = f"削除処理中にエラーが発生しました:\n\nエラータイプ: {type(e).__name__}\nエラー詳細: {str(e)}\n\nバックアップファイルから復元してください。"
            messagebox.showerror("処理エラー", error_msg)
            self.status_var.set("エラー: 削除処理失敗")
            
            # バックアップがある場合は復元オプションを提示
            if backup_path and os.path.exists(backup_path):
                restore_msg = f"エラーが発生しました。バックアップファイルから復元しますか?\n\nバックアップ: {os.path.basename(backup_path)}"
                if messagebox.askyesno("復元", restore_msg):
                    try:
                        shutil.copy2(backup_path, self.file_path)
                        self.load_file()
                        messagebox.showinfo("復元完了", "バックアップファイルから復元しました")
                        self.status_var.set("バックアップから復元完了")
                    except Exception as restore_error:
                        messagebox.showerror("復元エラー", f"復元に失敗しました:\n{restore_error}")
    
    def check_file_accessibility(self):
        """ファイルがアクセス可能か確認"""
        try:
            # ファイルを書き込みモードで開いてみる（実際には書き込まない）
            with open(self.file_path, 'r+b') as f:
                pass
        except PermissionError:
            raise PermissionError(f"ファイルがロックされています: {self.file_path}")
        except FileNotFoundError:
            raise FileNotFoundError(f"ファイルが見つかりません: {self.file_path}")


def main():
    root = tk.Tk()
    app = ExcelSheetDeleterGUI(root)
    root.mainloop()


if __name__ == "__main__":
    main()
